==============================
14.11 输出警告信息
==============================

----------
问题
----------
You want to have your program issue warning messages (e.g., about deprecated features
or usage problems).

|

----------
解决方案
----------
To have your program issue a warning message, use the warnings.warn() function. For
example:

import warnings

def func(x, y, logfile=None, debug=False):
    if logfile is not None:
         warnings.warn('logfile argument deprecated', DeprecationWarning)
    ...

The arguments to warn() are a warning message along with a warning class, which is
typically  one  of  the  following:  UserWarning,  DeprecationWarning,  SyntaxWarning,
RuntimeWarning, ResourceWarning, or FutureWarning.
The handling of warnings depends on how you have executed the interpreter and other
configuration. For example, if you run Python with the -W all option, you’ll get output
such as the following:

    bash % python3 -W all example.py
    example.py:5: DeprecationWarning: logfile argument is deprecated
      warnings.warn('logfile argument is deprecated', DeprecationWarning)

Normally, warnings just produce output messages on standard error. If you want to turn
warnings into exceptions, use the -W error option:

    bash % python3 -W error example.py
    Traceback (most recent call last):
      File "example.py", line 10, in <module>
        func(2, 3, logfile='log.txt')
      File "example.py", line 5, in func
        warnings.warn('logfile argument is deprecated', DeprecationWarning)
    DeprecationWarning: logfile argument is deprecated
    bash %

|

----------
讨论
----------
Issuing a warning message is often a useful technique for maintaining software and
assisting users with issues that don’t necessarily rise to the level of being a full-fledged
exception. For example, if you’re going to change the behavior of a library or framework,
you can start issuing warning messages for the parts that you’re going to change while
still providing backward compatibility for a time. You can also warn users about prob‐
lematic usage issues in their code.
As another example of a warning in the built-in library, here is an example of a warning
message generated by destroying a file without closing it:

>>> import warnings
>>> warnings.simplefilter('always')
>>> f = open('/etc/passwd')
>>> del f
__main__:1: ResourceWarning: unclosed file <_io.TextIOWrapper name='/etc/passwd'
 mode='r' encoding='UTF-8'>
>>>

By default, not all warning messages appear. The -W option to Python can control the
output  of  warning  messages.  -W  all  will  output  all  warning  messages,  -W  ignore
ignores all warnings, and -W error turns warnings into exceptions. As an alternative,
you  can  can  use  the  warnings.simplefilter()  function  to  control  output,  as  just
shown. An argument of always makes all warning messages appear, ignore ignores all
warnings, and error turns warnings into exceptions.
For simple cases, this is all you really need to issue warning messages. The warnings
module provides a variety of more advanced configuration options related to the fil‐
tering and handling of warning messages. See the Python documentation for more 
information.

